# 순열
# N개의 원소 중에서 R개를 뽑아서 순서 있게 나열하기.
# 순열은 앞에 나왔는지, 안 나왔는지가 중요
# visited는 해당 숫자가 사용됐는지, 안됐는지 확인

arr = [1, 2, 3]
N = len(arr)
R = 3

visited = [False] * N # 해당 숫자가 사용되었는지 여부 저장
res = [0] * 3 # 출력 배열(뽑은 숫자를 순서대로 저장할 배열)

# 재귀함수의 설계
# - R개를 뽑아야 한다면, R개를 한번에 뽑는 것이 아니라,
#   1개만 뽑고, 나머지 R-1개는 그 다음 재귀호출에 넘긴다.
# - 한번에 하나만 처리하고, 나머지는 그 다음 재귀 호출에서 처리
# - ex) 0번 위치 하나만 뽑고, 나머지(1, 2, ..., R-1)는 그 다음 재귀 함수가 처리
# - ex) 1번 위치 하나만 뽑고, 나머지(2, 3, ..., R-1)
# - ex) n번 위치 하나를 뽑았다면, 나머지는(n+1 ~ R-1) 그 다음 재귀 함수가 처리

# 재귀함수
# - 구조: 두 가지 파트로 나뉨
# - 1. 기저조건(base case) : 재귀함수가 끝나는 조건, 더이상 자기자신을 호출하지 않는 경우
# - 2. 유도조건: 자기자신을 호출하는 경우

# 스택으로도 생각할 수 있음


def perm(idx): # res 인덱스 헷갈리지 않기
    print(f"perm({idx})")
    # print(res)
    # 1. 기저조건
    if idx == R: # 기저조건
        # 재귀호출 하지 않음
        print(res)
        return # 함수를 종료
    # 그 다음을 호출한다.

    # 2. 유도조건
    # 아직 뽑지 않은 숫자 중에서 숫자를 뽑고, 그 다음 숫자를 뽑으러 가야 함.
    for i in range(N): # arr 인덱스 헷갈리지 않기
        if not visited[i]: # 5개 숫자 중에서 i번째를 뽑지 않았다면
            visited[i] = True # i번째 숫자를 뽑는다.
            print(arr[i],"를 방문처리")
            res[idx] = arr[i] # i번째 숫자를 idx번째에 저장
            print(idx,"번재에 ", arr[i], "저장")
            perm(idx+1) # 그 다음 자리 수 뽑으러 가기
            visited[i] = False # 방문처리 초기화 -> 중요
            print(arr[i]," 방문처리 취소")

    print(f"perm({idx}) end")

# N개의 원소 중에서
# 0, 1, ..., R-1까지 뽑아야함.
perm(0) # 0번 위치 하나만 뽑아라