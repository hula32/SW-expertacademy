arr = [1, 2, 3, 4, 5]

# 부분집합
# - 각 원소를 포함할 것인가? 포함하지 않을 것인가?
# - 비트마스킹(0 or 1)
# - 비트마스킹이 아닌 재귀함수로 진행

# 순열은 뽑는 순서를 생각해야함
N = len(arr)
out = [False] * N # 출력배열(해당 위치 포함 여부)

# 재귀함수 설계
# arr의 0번째 ~ N-1번째 수까지 각 수의 포함여부 결정하기
# N개의 수를 한번에 모두 결정하지 않는다.
# 1개씩만 처리
# ex) 0번째만 포함여부 결정하고 1~N-1은 나중에 결정
# ex) 1번째만 결정하고         2~N-1은 나중에 결정

def f(idx):
    # 기저조건
    if idx == N: # N-1까지는 결정할 원소가 있지만 N번 인덱스는 그런 원소 없음(리스트 범위 밖)
        # print(out)
        for i in range(N):
            if out[i]:
                print(arr[i], end = ' ')
        print()
        return
    
    # 유도조건 (N-1)까지는 뽑을지 말지 결정 가능.
    out[idx] = True # idx번째 부분집합에 포함시키고
    f(idx+1) # # idx+1번째 결정하러 가기
    out[idx] = False # # idx번째를 포함시키지 말고
    f(idx+1) # # idx+1번째 결정하러 가기



f(0) # 0번째 인덱스를 포함할지 말지 결정.