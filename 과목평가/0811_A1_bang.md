# answer.md

## 상황 1) A처럼 **중복이 많고 값의 범위(K)가 작을 때**
- **선택 알고리즘:** **카운팅 정렬 (Counting Sort)**
- **이유:**  
  - 값의 범위가 0~10처럼 작고 정수이므로, 빈도 배열을 만들어 **O(N+K)** 시간에 정렬 가능  
  - 중복이 많아도 빈도 계산만 하면 되어 **효율적**  
  - 추가 배열(카운트 배열, 결과 배열) 필요 → **추가 메모리 O(N+K)**  
  - **안정 정렬**로, 같은 값의 원래 순서를 유지 가능

---

## 상황 2) **추가 배열을 만들 수 없고** 값의 범위도 **알 수 없을 때**
- **선택 알고리즘:** **선택 정렬 (Selection Sort)**  
  *(버블 정렬도 가능하지만, 선택 정렬은 교환 횟수가 O(N)으로 적어 단순/예측 가능)*
- **이유:**  
  - **제자리(in-place)** 정렬 → 추가 메모리 거의 0  
  - 값 범위를 몰라도 **비교 기반**이므로 사용 가능  
  - 시간복잡도는 항상 **O(N²)**이지만, 메모리 제약 상황에서는 현실적인 선택  
  - **불안정 정렬** → 같은 값의 상대 순서가 바뀔 수 있음

---

## 상황 3) B처럼 **이미 거의 정렬된 상태일 때**
- **선택 알고리즘:** **버블 정렬 (Bubble Sort)** *(조기 종료 최적화 적용)*  
- **이유:**  
  - 한 패스에서 **교환이 0번이면 즉시 종료** → 거의 정렬된 경우 **거의 O(N)**  
  - **제자리 정렬**, **안정 정렬**  
  - 선택 정렬은 항상 O(N²)이라 비효율적  
  - 카운팅 정렬은 추가 배열 필요 + “거의 정렬”에서 이점 없음

---

## 📊 알고리즘 특성 비교표

| 알고리즘 | 최선 | 평균/최악 | 추가 공간 | 안정성 | 특징 |
|----------|------|-----------|-----------|--------|------|
| 버블 정렬 | O(N) *(조기 종료)* | O(N²) | O(1) | 안정 | 거의 정렬 시 빠름 |
| 선택 정렬 | O(N²) | O(N²) | O(1) | 불안정 | 교환 횟수 O(N) |
| 카운팅 정렬 | O(N+K) | O(N+K) | O(N+K) | 안정 | K가 작을 때 매우 효율적 |
