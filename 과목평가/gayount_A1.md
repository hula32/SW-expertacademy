## 드론 소독 작전 해설

1. 소독 범위 계산 시 중심점 반드시 포함하기


문제에서 스프레이나 드론 소독은 중심 칸부터 시작해서 각 방향으로 M칸까지 영향을 준다고 명시되어 있다. 즉, 중심 칸의 바이러스 수도 소독 대상에 반드시 포함해야 한다. 코드 구현 시 중심 칸 값을 별도로 더해줘야 하며, 이후 각 방향으로 거리 1부터 M-1칸까지 확장해서 더한다.


2. 거리 계산에서 중심점 제외 여부에 주의


거리 계산 루프에서 m을 0부터 시작하는 게 아니라 보통 1부터 시작하는 이유는, 중심 칸(거리 0)은 이미 포함시켰기 때문이다. 만약 중심 칸 포함을 깜빡하고 거리 0부터 더하면, 중심 칸 값이 두 번 더해질 수 있다.



3. 경계 검사 시 중심 칸 유무

중심 칸은 항상 격자 내부 위치이므로 경계 체크에서 예외 없이 더해진다. 그러나 각 방향으로 확장할 때는 격자를 벗어날 수 있으니, 인덱스가 유효한지 꼭 확인해야 한다.


4. 결과 최대값 비교 시 중심 포함한 총합 기준

중심 칸 포함한 소독 범위 합이 최대가 되는 위치와 방향(+ 또는 x)을 찾아야 하므로, 계산 결과가 중심 포함 값인지 확인하는 것이 필요하다.



```python

# 방향 설정: + 모양 (상, 하, 좌, 우)
dr = [-1, 1, 0, 0]
dc = [0, 0, -1, 1]

# 방향 설정: x 모양 (대각선 4방향)
dr2 = [1, 1, -1, -1]
dc2 = [1, -1, 1, -1]

# 테스트 케이스 개수 입력 받기
T = int(input())


# 각 테스트 케이스에 대해 반복
for tc in range(1, T + 1):
    # N: 격자 크기, M: 소독 세기 입력
    N, M = map(int, input().split())
    # N x N 격자판에 바이러스 수 입력
    arr = [list(map(int, input().split())) for _ in range(N)]

    # 최대 바이러스 제거 수 초기화
    max_val = 0

    # + 모양 소독 영역 탐색
    for r in range(N):          # 격자판 모든 행 반복
        for c in range(N):      # 격자판 모든 열 반복
            total = arr[r][c]  # 현재 칸(중심) 바이러스 수 먼저 더하기

            # 상하좌우 4방향으로 M-1 칸씩 더함
            for d in range(4):  # 4방향 반복 (0:상, 1:하, 2:좌, 3:우)
                for m in range(1, M):  # 중심 제외, 거리 1부터 M-1까지 반복
                    nr = r + dr[d] * m  # 새 행 위치 계산
                    nc = c + dc[d] * m  # 새 열 위치 계산
                    # 새 위치가 격자 범위 내인지 확인
                    if 0 <= nr < N and 0 <= nc < N:
                        total += arr[nr][nc]  # 바이러스 수 누적

            # 탐색한 영역 바이러스 합이 최대값이면 갱신
            if total > max_val:
                max_val = total

    # x 모양 소독 영역 탐색 (대각선)
    for r in range(N):
        for c in range(N):
            total = arr[r][c]  # 중심 칸 바이러스 수

            # 4개 대각선 방향으로 M-1 칸씩 더함
            for d in range(4):
                for m in range(1, M):
                    nr = r + dr2[d] * m
                    nc = c + dc2[d] * m
                    if 0 <= nr < N and 0 <= nc < N:
                        total += arr[nr][nc]

            if total > max_val:
                max_val = total

    # 결과 출력 (테스트 케이스 번호와 최대값)
    print(f"#{tc} {max_val}")

```


